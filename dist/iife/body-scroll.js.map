{"version":3,"file":"body-scroll.js","sources":["../../src/body-scroll.client.mjs","../../src/body-scroll.utils.mjs","../../src/body-scroll.scroll.mjs","../../src/body-scroll.style.mjs","../../src/body-scroll.state.mjs","../../src/body-scroll.mjs"],"sourcesContent":["// caching involved dom elements\nexport const head = document.head;\nexport const body = document.body;\nexport const html = document.documentElement;\nexport const styler = document.createElement(\"style\");\n\n/**\n * Dispatches the given message name in jQuery.Event\n * @private\n * @param {String} messageName The given message name to be dispatched\n * @returns {void} Nothing\n */\nexport const dispatchMessage = (messageName) =>\n    typeof window.CustomEvent === \"function\"\n        ? window.dispatchEvent(new CustomEvent(`bodyscroll${messageName}`))\n        : () => {};\n\n//\nconst lockedStateCssClass = \"body-scroll-lock\";\n\n/**\n * Toggles the locked state css class to html element\n * @param {Boolean} bool Whether the class should be added ro removed\n * @returns {Boolean} Whether the removal or the\n */\nconst toggleLockedCssClass = (bool) => {\n    const hadClass = html.classList.contains(lockedStateCssClass);\n\n    bool = bool ?? !hadClass;\n\n    html.classList.toggle(lockedStateCssClass, bool);\n\n    return (bool && !hadClass) || (!bool && hadClass);\n};\n\n/**\n *\n * @returns {Boolean}\n */\nexport const addLockedCssClass = () => toggleLockedCssClass(true);\n\n/**\n *\n * @returns {Boolean}\n */\nexport const removeLockedCssClass = () => toggleLockedCssClass(false);\n","/**\n * Checks whether a given value is a valid number or not\n * @static\n * @private\n * @param {any} value The given value to be checked\n * @returns {Boolean} True if the given value is a number\n */\nexport const isNumber = (value) => typeof value === \"number\" && !isNaN(value);\n","import { isNumber } from \"./body-scroll.utils.mjs\";\n\n// scroll position saving closure\nlet scrollSaving = null;\n\n/**\n * Checks whether a given value is a valid scroll object or not\n * @example\n * isValidScrollPosition({top:0, left:100}); // true\n * isValidScrollPosition(null); // false\n * isValidScrollPosition({top:\"foo\", left:NaN}); // false\n * @static\n * @private\n * @param {Object} value The given value to be checked\n * @returns {Boolean} True if the given value is a valid scroll object\n */\nexport const isValidScrollPosition = (value) =>\n    value && isNumber(value?.top) && isNumber(value?.left);\n\n/**\n * Formats a given scroll position object value, if malformed returns null\n * @static\n * @private\n * @param {Object} value The given value to be formatted\n * @returns {Object|null} The given value is returned if is a valid scroll position object, otherwise null is returned\n */\nexport const formatScrollPosition = (value) =>\n    isValidScrollPosition(value) ? value : null;\n\n/**\n * Restores a given valid scroll position object, if not passed possibly restores a previously saved scroll position object\n * @public\n * @param {Object} [scroll] The given scroll object to be restored\n * @returns {Object|null} The given value is returned if is a valid scroll position object, otherwise null is returned\n */\nexport const restoreScrollPosition = (scroll) => {\n    scroll = scroll !== undefined ? scroll : scrollSaving;\n    scroll = formatScrollPosition(scroll);\n\n    if (scroll) {\n        window.scrollTo(scroll.left, scroll.top);\n    }\n\n    return scroll;\n};\n\n/**\n * Saves a given valid scroll position object, if not passed saves the current body scroll position\n * @public\n * @param {Object} [scroll] The given scroll position object to be saved\n * @returns {Object|null} The given value is returned if is a valid scroll position object, otherwise null is returned\n */\nexport const saveScrollPosition = (scroll) => {\n    if (scroll === undefined) {\n        scroll = {\n            top: window.pageYOffset,\n            left: window.pageXOffset\n        };\n    }\n\n    scrollSaving = formatScrollPosition(scroll);\n\n    return scrollSaving;\n};\n\n/**\n * Returns the currently saved scroll position object\n * @public\n * @returns {Object|null} The currently saved scroll position object, null if nothing was saved\n */\nexport const getSavedScrollPosition = () => scrollSaving;\n\n/**\n * Returns the currently saved scroll position object\n * @public\n * @returns {Object|null} The currently saved scroll position object, null if nothing was saved\n */\nexport const clearSavedScrollPosition = () => (scrollSaving = null);\n","import {\n    isValidScrollPosition,\n    getSavedScrollPosition\n} from \"./body-scroll.scroll.mjs\";\nimport {\n    html,\n    head,\n    body,\n    styler,\n    addLockedCssClass,\n    removeLockedCssClass\n} from \"./body-scroll.client.mjs\";\n\n/**\n * Gets the current vertical scrollbar width size in px unit\n * @public\n * @returns {Number} The current vertical scrollbar width in px\n */\nexport const getVerticalScrollbarGap = () => {\n    // NOTE: right now this is the safest and more robust way to detect the real document scrollbar size (compatible with iOS pinch to zoom)\n    // bodyscroll is gonna change overflow property anyway, so we keep this not 100% clean approach for now\n\n    // clears possible body scroll lock state css strategies\n    const hasClassRemoved = removeLockedCssClass();\n\n    // caches current html element width\n    // NOTE: right now only getBoundingClientRect grant sub pixel measures, repaint would have been done anyway so...\n    var docWidth = html.getBoundingClientRect().width;\n\n    // fixes current body element width to avoid page jump due to overflow value change\n    body.style.width = body.getBoundingClientRect().width + \"px\";\n    // sets overflow property to hidden\n    html.style.overflowY = body.style.overflowY = \"hidden\";\n\n    // gets the actual scrollbar width comparing the cached html width to the current one with overflow hidden on\n    var scrollbarWidth = html.getBoundingClientRect().width - docWidth;\n\n    // cleans everything up\n    body.style.width = html.style.overflowY = body.style.overflowY = \"\";\n\n    // possibly re applies body scroll lock state css strategies\n    if (hasClassRemoved) {\n        addLockedCssClass();\n    }\n\n    // returns the vertical scrollbar width\n    return scrollbarWidth;\n};\n\n/**\n * Updates css variables to the current state\n * @public\n * @returns {void} Nothing\n */\nexport const updateCssVariables = () => {\n    // ensuring style presence, StyleSheet API throws otherwise\n    if (!body.contains(styler)) {\n        head.append(styler);\n    }\n\n    // only rule\n    const index = 0;\n\n    // clean up past rules\n    if (styler.sheet.cssRules[index]) {\n        styler.sheet.deleteRule(index);\n    }\n\n    // calculating scrollbar gap\n    const verticalScrollbarGap = getVerticalScrollbarGap();\n    // gets the current scroll position object saving or default\n    const scrollSaving = getSavedScrollPosition();\n    const scrollPosition = isValidScrollPosition(scrollSaving)\n        ? scrollSaving\n        : { top: 0, left: 0 };\n\n    // composes updated css variables rule\n    const rule = `:root {\n        --body-scroll-lock-top-rect: ${scrollPosition.top * -1}px;\n        --body-scroll-lock-vertical-scrollbar-gap: ${verticalScrollbarGap}px;\n        --body-scroll-lock-vertical-scrollbar-gap-round: ${Math.round(\n            verticalScrollbarGap\n        )}px;\n    }`;\n\n    // sets new rule up\n    styler.sheet.insertRule(rule, index);\n};\n","import {\n    dispatchMessage,\n    addLockedCssClass,\n    removeLockedCssClass\n} from \"./body-scroll.client.mjs\";\nimport {\n    isValidScrollPosition,\n    getSavedScrollPosition,\n    saveScrollPosition,\n    clearSavedScrollPosition,\n    restoreScrollPosition\n} from \"./body-scroll.scroll.mjs\";\nimport { updateCssVariables } from \"./body-scroll.style.mjs\";\n\n// lock state flag closure, true if is locked\nlet lockState = false;\n\n/**\n * Returns the current lock state as a boolean\n * @public\n * @returns {Boolean} True if body scroll is locked, false if not\n */\nexport const isLocked = () => lockState;\n\n/**\n * Locks the body scroll, saves current body scroll position (if not already saved) and updates css variables\n * @private\n * @returns {Boolean} True if the lock has been successfully done, false if not\n */\nexport const doLock = () => {\n    // don't lock when already locked, lock not done, returns false early\n    if (isLocked()) {\n        return false;\n    }\n\n    // sets the lock state to true\n    lockState = true;\n\n    // saves current scroll position if there's not another saving state\n    if (!isValidScrollPosition(getSavedScrollPosition())) {\n        saveScrollPosition({\n            top: window.pageYOffset,\n            left: window.pageXOffset\n        });\n    }\n\n    // calculates and applies :root css variables to grant body scroll lock css techniques\n    updateCssVariables();\n\n    // applies body scroll lock css techniques\n    addLockedCssClass();\n\n    // lock done, returns true\n    return true;\n};\n\n/**\n * Unlocks the body scroll, restores the scroll position previously saved and clears the saving\n * @private\n * @returns {Boolean} True if the unlock has been successfully done, false if not\n */\nexport const doUnlock = () => {\n    // don't unlock when already unlocked, unlock not done, returns false early\n    if (!isLocked()) {\n        return false;\n    }\n\n    // sets the lock state to false\n    lockState = false;\n\n    // clears body scroll lock css techniques that could prevent scroll restoration\n    removeLockedCssClass();\n\n    // restores previously saved scroll position\n    restoreScrollPosition(getSavedScrollPosition());\n\n    // clears the scroll position saving\n    clearSavedScrollPosition();\n\n    // unlock done, returns true\n    return true;\n};\n\n/**\n * Locks the body scroll\n * @public\n * @returns {void} Nothing\n */\nexport const lock = () => {\n    // returns early if lock itself hasn't been successful\n    if (!doLock()) {\n        return;\n    }\n\n    // dispatch a \"lock done\" notification\n    dispatchMessage(\"lock\");\n};\n\n/**\n * Unlocks the body scroll\n * @public\n * @returns {void} Nothing\n */\nexport const unlock = () => {\n    // returns early if unlock itself hasn't been successful\n    if (!doUnlock()) {\n        return;\n    }\n\n    // dispatch an \"unlock done\" notification\n    dispatchMessage(\"unlock\");\n};\n","import { dispatchMessage } from \"./body-scroll.client.mjs\";\nimport {\n    lock,\n    unlock,\n    isLocked,\n    doLock,\n    doUnlock\n} from \"./body-scroll.state.mjs\";\nimport {\n    updateCssVariables,\n    getVerticalScrollbarGap\n} from \"./body-scroll.style.mjs\";\nimport {\n    restoreScrollPosition,\n    saveScrollPosition,\n    getSavedScrollPosition\n} from \"./body-scroll.scroll.mjs\";\n\n// handling browser resize (implicitly includes a possible device orientation change)\n// re applying a consistent lock state when body scroll is locked\nlet id = null;\nconst resizeHandler = () => {\n    clearTimeout(id);\n\n    id = setTimeout(() => {\n        // toggling body scroll lock\n\n        // gets rid of possible body scroll locked state\n        // avoids useless computations when scroll is not locked\n        if (!doUnlock()) {\n            return;\n        }\n\n        // recalculates and rewrites lock state\n        doLock();\n\n        // dispatch a \"resize during lock\" notification\n        dispatchMessage(\"resize\");\n    }, 150);\n};\nwindow.addEventListener(\"resize\", resizeHandler, true);\n\n// public API\nexport default {\n    // main\n    lock: lock,\n    unlock: unlock,\n    isLocked: isLocked,\n    // extras\n    updateCssVariables: updateCssVariables,\n    getVerticalScrollbarGap: getVerticalScrollbarGap,\n    restoreScrollPosition: restoreScrollPosition,\n    saveScrollPosition: saveScrollPosition,\n    getSavedScrollPosition: getSavedScrollPosition\n};\n"],"names":["head","document","body","html","documentElement","styler","createElement","dispatchMessage","messageName","window","CustomEvent","dispatchEvent","lockedStateCssClass","toggleLockedCssClass","bool","hadClass","classList","contains","toggle","addLockedCssClass","removeLockedCssClass","isNumber","value","isNaN","scrollSaving","isValidScrollPosition","top","left","formatScrollPosition","restoreScrollPosition","scroll","undefined","scrollTo","saveScrollPosition","pageYOffset","pageXOffset","getSavedScrollPosition","clearSavedScrollPosition","getVerticalScrollbarGap","hasClassRemoved","docWidth","getBoundingClientRect","width","style","overflowY","scrollbarWidth","updateCssVariables","append","index","sheet","cssRules","deleteRule","verticalScrollbarGap","scrollPosition","rule","Math","round","insertRule","lockState","isLocked","doLock","doUnlock","lock","unlock","id","resizeHandler","clearTimeout","setTimeout","addEventListener"],"mappings":"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"}